tc qdisc add dev %(dev)s root handle 1: htb default 30

# match le traffic et redirige vers les bonnes queues htb
for port in %(shaping:ports_prio)s ; do
    tc filter add dev %(shaping:dev)s protocol ip parent 1:0 prio 1 u32 match ip dport $port 0xffff flowid 1:10
done
    for port in %(shaping:ports_data)s ; do
    tc filter add dev %(shaping:dev)s protocol ip parent 1:0 prio 1 u32 match ip dport $port 0xffff flowid 1:20
done

if [ %(shaping:out_shaping)s != "N" ] ; then
    tc class add dev %(shaping:dev)s parent 1: classid 1:1 htb rate %(shaping:out)skbit burst %(shaping:out_burst)sk
    tc class add dev %(shaping:dev)s parent 1:1 classid 1:10 htb rate $[%(shaping:out)s*8/10]kbit burst %(shaping:out_burst)sk
    tc class add dev %(shaping:dev)s parent 1:1 classid 1:20 htb rate $[%(shaping:out)s/2]kbit ceil %(shaping:out)skbit burst %(shaping:out_burst)sk
    tc class add dev %(shaping:dev)s parent 1:1 classid 1:30 htb rate 1kbit ceil %(shaping:out)skbit burst %(shaping:out_burst)sk
    # ajout de sous-classes sfq
    tc qdisc add dev %(shaping:dev)s parent 1:10 handle 10: sfq perturb 10
    tc qdisc add dev %(shaping:dev)s parent 1:20 handle 20: sfq perturb 10
    tc qdisc add dev %(shaping:dev)s parent 1:30 handle 30: sfq perturb 10
fi

if [ %(shaping:in_shaping)s != "N" ] ; then
# basic input shaping, work not so bad up to 100ms latency and 0.1% loss
tc qdisc add dev %(shaping:dev)s handle ffff: ingress
tc filter add dev %(shaping:dev)s parent ffff: protocol ip prio 50 u32 match ip src \
    0.0.0.0/0 police rate %(shaping:in)skbit burst %(shaping:in_burst)sk drop flowid :1
fi


