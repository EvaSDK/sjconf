import re, sys, os, ConfigParser, errno, time, popen2

class Type:

    @classmethod
    def str_to_list(xcls, str_object):
        list = map(str.strip, str_object.split(','))
        try:
            list.remove('')
        except ValueError:
            pass
        return list

    @classmethod
    def list_to_str(xcls, list):
        return ', '.join(list)

class Conf(dict):
    class ConfSection(dict):
        def __init__(self, *args, **kw):
            dict.__init__(self, *args, **kw)
            self.types = {}

        def __delitem__(self, key):
            dict.__delitem__(self, key)
            if key in self.types:
                del self.types[key]

        def __find_type(self, key):
            type = None
            search_result = re.compile('(.*)_([^_]+)$').search(key)
            if search_result:
                key_tmp = search_result.group(1)
                type = search_result.group(2)
                if key_tmp in self.types and type == self.types[key_tmp][0]:
                    key = key_tmp
                else:
                    type = None
            return key, type

        def __getitem__(self, key):
            key, type = self.__find_type(key)
            value = dict.__getitem__(self, key)
            if type:
                value = self.types[key][1]
            elif key in self.types:
                value = apply(getattr(Type, self.types[key][0] + '_to_str'), [self.types[key][1]])
                dict.__setitem__(self, key, value)
            return value

        def __setitem__(self, key, value):
            key, type = self.__find_type(key)
            if type:
                self.types[key][1] = value
                value = apply(getattr(Type, self.types[key][0] + '_to_str'), [value])
            elif key in self.types:
                self.types[key][1] = apply(getattr(Type, 'str_to_' + self.types[key][0]), [value])
            dict.__setitem__(self, key, value)

        def set_type(self, key, type):
            self.types[key] = [type, apply(getattr(Type, 'str_to_' + type), [self[key]])]

    def __init__(self, file_name, default_value = None):
        dict.__init__({})
        self.file_name = file_name
        self.comments = None
        try:
            self.load()
        except IOError, exception:
            if exception.errno == errno.ENOENT and default_value != None:
                for key in default_value:
                    self[key] = default_value[key]
            else:
                raise

    def load(self, file_name = None):
        if not file_name:
            file_name = self.file_name
        # Configuration file loader
        if not os.path.exists(file_name):
            raise IOError(errno.ENOENT, "%s: %s" % (self.file_name, os.strerror(errno.ENOENT)))
        elif os.path.isdir(file_name):
            raise IOError(errno.EISDIR, "%s: %s" % (self.file_name, os.strerror(errno.EISDIR)))
        cp = ConfigParser.ConfigParser()
        cp.read(file_name)
        for section in cp.sections():
            self[section] = Conf.ConfSection(cp.items(section))

    def save(self, file_name = None):
        if not file_name:
            file_name = self.file_name
        output_file = open(file_name, "w")
        if self.comments != None and len(self.comments) > 0:
            for comment in comments.split('\n'):
                output_file.write('# ' + comment + '\n')
            output_file.write('\n')
        cp = ConfigParser.ConfigParser()
        for section in self:
            cp.add_section(section)
            for key in self[section]:
                cp.set(section, key, self[section][key])
        cp.write(output_file)

    def set_type(self, section, key, type):
        self[section].set_type(key, type)

class SJConf:

    BASE_COMMENTS           = """
/!\ WARNING /!\
Do not edit this file ! Your modifications will be overwritten at next upgrade.
Instead, add your custom values in local.conf.
"""

    DEFAULT_SJCONF_FILE_NAME = '/etc/smartjog/sjconf.conf'

    def __init__(self, sjconf_file_name = DEFAULT_SJCONF_FILE_NAME, quiet = True, verbose = False):

        self.confs_internal = {'sjconf' : Conf(sjconf_file_name)}
        self.confs_internal['sjconf'].set_type('conf', 'plugins', 'list')
        for conf in ('installed_confs'):
            conf_file_name = os.path.realpath(self.confs_internal['sjconf']['conf']['internal_config_path'] + '/' + conf + '.conf')
            self.confs_internal[conf] = Conf(conf_file_name, {})

        self.confs = {}
        for conf in ('base', 'local'):
            conf_file_name = os.path.realpath(self.confs_internal['sjconf']['conf']['base_path'] + '/' + conf + '.conf')
            self.confs[conf] = Conf(conf_file_name)
        self.confs['base'].comments = self.BASE_COMMENTS

        self.backup_dir = os.path.realpath(self.confs_internal['sjconf']['conf']['backup_dir'] + '/' + time.strftime('%F-%R:%S', time.localtime()))

        self.temp_file_name = "/tmp/sjconf_tempfile.conf"

        self.files_path = {'plugin' : os.path.realpath(self.confs_internal['sjconf']['conf']['plugins_path']), 'template' : os.path.realpath(self.confs_internal['sjconf']['conf']['templates_path'])}
        self.files_extensions = {'plugin' : ('.py'), 'template' : ('.conf')}

        sys.path.append(self.files_path['plugin'])

        self.plugins = []

        self.quiet = quiet
        self.verbose = verbose

    def get_conf(self):
        conf = {}
        # Creating a dict with list of base conf dicts
        for dic_key in self.confs['base']:
            for key in self.confs['base'][dic_key]:
                conf['%s:%s' % (dic_key, key)] = self.confs['base'][dic_key][key]

        # Updating this dict with list of local conf dicts
        for dic_key in self.confs['local']:
            for key in self.confs['local'][dic_key]:
                conf['%s:%s' % (dic_key, key)] = self.confs['local'][dic_key][key]
        return conf

    def restart_services(self, services_to_restart):
        self.__plugins_load()
        already_restart = []
        for plugin in self.plugins:
            if plugin.SERVICE_NAME in services_to_restart or 'all' in services_to_restart:
                plugin.restart_service(self.confs_internal['sjconf'], already_restart)

    def apply_conf_modifications(self, sets = {}, delete_keys = {}, delete_sections = {}, temp = False):
        conf = self.confs['local']
        if sets or delete_keys or delete_sections:
            self.__my_print("########## Scheduled modifications ##############")

            for section in delete_sections:
                if section in conf:
                    del(conf[section])
                self.__my_print('delete section : %s' % (section))

            for section, key in delete_keys:
                if section in conf:
                    if key in conf[section]:
                        del(conf[section][key])
                self.__my_print('delete key     : %s:%s' % (section, key))

            for section, key, value in sets:
                conf.setdefault(section, {})
                conf[section][key] = value
                self.__my_print('set            : %s:%s=%s' % (section, key, value))
            self.__my_print("#################################################\n")

        if temp:
            output_file = self.temp_file_name
        else:
            output_file = conf.file_name
        conf.save(output_file)

    def deploy_conf(self, restart, services_to_restart):
        self.__plugins_init()
        backuped_files = self.__backup_files()

        try:
            # Write all configuration files
            self.__apply_confs()

            # restart services if asked
            if restart:
                self.restart_services(services_to_restart)
            self.__my_print('')
        except:
            # Something when wrong, restoring backup files
            self.__restore_files(backuped_files)
            if restart:
                self.restart_services(services_to_restart)
            # And delete backup folder
            self.__delete_backup_dir()
            raise
        # Only archive once everything is OK
        self.__archive_backup()
        self.__my_print('')
        # Delete backup, everything is cool
        self.__delete_backup_dir()

    def file_install(self, file_type, file_to_install, link=False):
        if self.verbose:
           self. __my_print("Installing file: %s" % (file_to_install))
        if os.path.exists(self.files_path[file_type] + '/' + os.path.basename(file_to_install)):
            raise IOError(errno.EEXIST, "file %s already installed" % (file_to_install))
        file_destination_path = self.files_path[file_type] + '/' + os.path.basename(file_to_install)
        if not link:
            if os.path.isdir(file_to_install):
                shutil.copytree(file_to_install, file_destination_path)
            else:
                shutil.copy(file_to_install, file_destination_path)
        else:
            os.symlink(os.path.realpath(file_to_install), file_destination_path)
        if self.verbose:
            self.__my_print("Installed file: %s" % (file_to_install))

    def file_uninstall(self, file_type, file_to_uninstall):
        if self.verbose:
            self.__my_print("Uninstalling file: %s" % (file_to_uninstall))
        file_to_uninstall_path = self.__file_path(file_type, file_to_uninstall)
        if not os.path.islink(file_to_uninstall_path) and os.path.isdir(file_to_uninstall_path):
            shutil.rmtree(file_to_uninstall_path)
        else:
            os.unlink(file_to_uninstall_path)
        if self.verbose:
            self.__my_print("Uninstalled file: %s" % (file_to_uninstall))

    def plugin_enable(self, plugin_to_enable):
        # ensure the plugin in installed
        self.__file_path('plugin', plugin_to_enable)
        plugins_list = self.confs_internal['sjconf']['conf']['plugins_list']
        if plugin_to_enable in plugins_list:
            raise IOError(errno.EEXIST, "plugin %s already enabled" % (plugin_to_enable))
        self.confs_internal['sjconf']['conf']['plugins_list'].append(plugin_to_enable)
        self.confs_internal['sjconf'].save()

    def plugin_disable(self, plugin_to_disable):
        # ensure the plugin in installed
        self.__file_path('plugin', plugin_to_disable)
        try:
            self.confs_internal['sjconf']['conf']['plugins_list'].remove(plugin_to_disable)
        except ValueError:
            raise IOError(errno.ENOENT, "plugin %s not enabled" % (plugin_to_disable))
        self.confs_internal['sjconf'].save()

    def conf_file_install(self, conf_file_to_install):
        conf_file_to_install_name = os.path.basename(conf_file_to_install).replace('.conf', '')
        if conf_file_to_install_name in self.confs_internal['sjconf']['installed_confs_list']:
            raise IOError(errno.EEXIST, "config %s is already installed" % (conf_file_to_install_name))
        conf_to_install = Conf(conf_file_to_install)
        for section in conf_to_install:
            for key in conf_to_install[section]:
                if not section in self.confs_internal['installed_confs']:
                    self.confs_internal['installed_confs'][section] = {}
                if key in self.confs_internal['installed_confs'][section] and self.confs_internal['installed_confs'][section][key] != conf_file_to_install_name:
                    raise IOError(errno.EEXIST, "the key %s in section %s is already installed by config %s" % (key, section, self.confs_internal['installed_confs'][section][key]))
                self.confs_internal['installed_confs'][section][key] = conf_file_to_install_name
                if not section in self.confs['base']:
                    self.confs['base'][section] = {}
                self.confs['base'][section][key] = conf_to_install[section][key]
        self.confs_internal['sjconf']['installed_confs_list'].append(conf_file_to_install_name)
        self.confs['base'].save()
        self.confs_internal['installed_confs'].save()
        self.confs_internal['sjconf'].save()

    def conf_file_uninstall(self, conf_file_to_uninstall):
        conf_file_to_uninstall_name = os.path.basename(conf_file_to_uninstall).replace('.conf', '')
        if not conf_file_to_uninstall_name in self.confs_internal['sjconf']['installed_confs_list']:
            raise IOError(errno.ENOENT, "config %s is not installed" % (conf_file_to_uninstall_name))
        keys_to_delete = {}
        for section in configs_installed:
            if section == 'sjconf':
                continue
            for key in self.confs_internal['installed_confs'][section]:
                if self.confs_internal['installed_confs'][section][key] == conf_file_to_uninstall_name:
                    if not section in keys_to_delete:
                        keys_to_delete[section] = []
                    keys_to_delete[section].append(key)
        for section in keys_to_delete:
            for key in keys_to_delete[section]:
                    del self.confs_internal['installed_confs'][section][key]
                    del self.confs['base'][section][key]
            if len(self.confs_internal['installed_confs'][section]) == 0:
                del self.confs_internal['installed_confs'][section]
            if len(self.confs['base'][section]) == 0:
                del self.confs['base'][section]
        self.confs_internal['sjconf']['installed_confs_list'].remove(conf_file_to_uninstall_name)
        self.confs['base'].save()
        self.confs_internal['installed_confs'].save()
        self.confs_internal['sjconf'].save()

    def __my_print(self, str):
        if not self.quiet: print str

    def __exec_command(self, command, input = ''):
        # Using popen to know program output
        cmd = popen2.Popen3(command, True)
        cmd.tochild.write(input)
        out = cmd.fromchild.read()
        err = cmd.childerr.read()
        exit_value = cmd.wait()

        return out, err, exit_value

    def __plugins_load(self):
        for plugin in self.confs_internal['sjconf']['conf']['plugins_list']:
            if not plugin in map(lambda plugin: plugin.__name__, self.plugins):
                self.plugins.append(__import__(plugin))

    def __get_files_to_backup(self):
        self.__plugins_load()
        files_to_backup = []
        # Ask all plugins a list of files that I should backup for them
        for plugin in self.plugins:
            files_to_backup += plugin.get_files_to_backup()
        return files_to_backup

    def __backup_files(self):
        files_to_backup = self.__get_files_to_backup()
        self.__my_print( "Backup folder : %s" % self.backup_dir )
        os.makedirs(self.backup_dir)
        os.makedirs(self.backup_dir + '/sjconf/')
        out, err, exit_value = self.__exec_command("cp '%s' '%s'" % (self.confs['local'].file_name, self.backup_dir + os.path.basename(self.confs['local'].file_name)))
        if exit_value != 0:
            raise err
        try:
        # Store all files into a service dedicated folder
            for file in files_to_backup:
                if not os.path.isdir(self.backup_dir + '/' + file['service']):
                    os.makedirs(self.backup_dir + '/' + file['service'])
                file['backup_path'] = self.backup_dir + '/' + file['service'] + '/' + os.path.basename(file['path'])
                out, err, exit_value = self.__exec_command("mv '%s' '%s'" % (file['path'], file['backup_path']))
                if exit_value != 0:
                    raise (err + '\nPlease restore files manually from %s' % self.backup_dir, files_to_backup)
                file['backed_up'] = True
        except:
            self.__restore_files(self, backuped_files)
            raise
        return files_to_backup

    def __archive_backup(self):
        # Once configuration is saved, we can archive backup into a tgz
        path = "%s/sjconf_backup_%s.tgz" % (os.path.dirname(self.backup_dir), os.path.basename(self.backup_dir))
        self.__my_print("Backup file : %s" % path)
        out, err, exit_value = self.__exec_command("tar zcvf %s %s" % (path, self.backup_dir))
        if exit_value != 0:
            raise err +  "\nCannot archive backup dir %s/ to %s, please do it manually" % (self.backup_dir, path)

    def __delete_backup_dir(self, dir=None):
        # Once backup has been archived, delete it
        if dir == None:
            dir = self.backup_dir
            self.__my_print("Deleting folder %s" % dir)

        for entry in os.listdir(dir):
            path = dir + '/' + entry
            if os.path.isdir(path):
                self.__delete_backup_dir(path)
            elif os.path.isfile(path):
                os.unlink(path)
        os.rmdir(dir)

    def __restore_files(self, backuped_files):
        # Something went wrong
        self.__my_print("Restoring files from %s" % self.backup_dir)

        # Unlink all conf files just created
        for file in backuped_files:
            if 'written' in file and file['written'] and os.path.isfile(file['path']):
                os.unlink(file['path'])

        # Restore backup files
        for file in backuped_files:
            if file['backed_up']:
                out, err, exit_value = self.__exec_command("mv '%s' '%s'" % (file['backup_path'], file['path']))
                if exit_value != 0:
                    raise err + "\nPlease restore files manually from %s" % self.backup_dir

    def __apply_confs(self):
        # Open and write all configuration files
        conf_files = self.__get_conf_files()
        for conf in conf_files:
            self.__my_print("Writing configuration file %(path)s (%(service)s)" % conf)
            # checking if the dirname exists
            folder = os.path.dirname(conf['path'])
            if not os.path.isdir(folder):
                os.makedirs(folder)
            open(conf['path'], "w").write(conf['content'])
            conf['written'] = True
        self.__my_print('')

    def __plugins_init(self):
        self.__plugins_load()
        self.restart = False
        for plugin in self.plugins:
            plugin.init(self.confs_internal['sjconf'], self.confs['base'], self.confs['local'], self.get_conf())

    def __get_conf_files(self):
        self.__plugins_load()
        conf_files = []
        for plugin in self.plugins:
            conf_files += plugin.get_conf_files()
        return conf_files

    def __file_path(self, file_type, file_name):
        file_path = file_name
        if not file_path.startswith(self.files_path[file_type]):
            file_path = self.files_path[file_type] + '/' + file_path
        for extension in self.files_extensions[file_type]:
            if os.path.exists(file_path):
                break
            file_path += extension
        if not os.path.exists(file_path):
            raise IOError(errno.ENOENT, "file %s not installed, path: %s" % (file_name, file_path))
        return file_path
