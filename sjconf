#!/usr/bin/python

import traceback, time, os, sys, popen2, ConfigParser
from pprint import pprint


def load_conf(filename):
    # Configuration file loader
    if not os.path.isfile(filename):
        sys.stderr.write('Cannot open file %s\n' % filename)
        sys.exit(1)
    cp = ConfigParser.RawConfigParser()
    cp.read(filename)
    return dict(map(lambda a, b:  (a , dict(cp.items(a))), cp.sections(), {}))
    
sjconf     = load_conf('/etc/smartjog/sjconf')

# Adding plugin folder to sys path
sys.path   += [sjconf['conf']['plugins_path']]

# and import known plugins
import intervpn, iptables, shaping, hosts

# Defining usefull variables
BASE_FILE  = os.path.realpath(sjconf['conf']['base_path'] + '/base.conf')
LOCAL_FILE = os.path.realpath(sjconf['conf']['base_path'] + '/local.conf')
BACKUP_DIR = os.path.realpath(sjconf['conf']['backup_dir'] + '/' + time.strftime('%F-%R:%S', time.localtime()) )
ETC_DIR    = os.path.realpath(sjconf['conf']['etc_dir'])
PLUGINS    = [intervpn, iptables, shaping, hosts]
TEMP_FILE  = "/tmp/sjconf_tempfile.conf"

base            = load_conf(BASE_FILE)
local           = load_conf(LOCAL_FILE)

# Global variables used on functions
global files_to_backup
global delete_sections
global delete_keys
global sets
global get
global deploy
global restart
global save
global diff
global verbose

config          = {}
config_files    = []
files_to_backup = []
get             = []
sets            = []
delete_keys     = []
delete_sections = []
restart         = []
deploy          = False
save            = False
diff            = False
verbose         = False

def print_traceback():
    traceback.print_exc(file=sys.stdout)


def backup_files():
    global files_to_backup

    print "Backup folder : %s" % BACKUP_DIR
    os.makedirs(BACKUP_DIR)

    # Ask all plugins a list of files that I should backup for them
    for plugin in PLUGINS:
        files_to_backup += plugin.get_files_to_backup()

    # Store all files into a service dedicated folder
    for file in files_to_backup:
        if not os.path.isdir( BACKUP_DIR + '/' + file['service']):
            os.makedirs(BACKUP_DIR + '/' + file['service'])
        file['backup_path'] = BACKUP_DIR + '/' + file['service'] + '/' + os.path.basename(file['path'])
        os.rename(file['path'], file['backup_path'])


def archive_backup():
    # Once configuration is saved, we can archive backup into a tgz

    path    = "%s/sjconf_backup_%s.tgz" % (os.path.dirname(BACKUP_DIR), os.path.basename(BACKUP_DIR))
    print "Backup file : %s" % path

    # Using popen to know program output
    tar     = popen2.Popen3( "tar zcvf %s %s" % (path, BACKUP_DIR) , True)
    fdout   = tar.fromchild.fileno()
    fderr   = tar.childerr.fileno()
    datout  = tar.fromchild.read()
    daterr  = tar.childerr.read()

    if tar.wait():
        print "Cannot archive backup dir %s/ to %s, please do it manually" % (BACKUP_DIR, path)
        print "tar output:\n\n" + daterr

def delete_backup_dir(dir=None):
    # Once backup has been archived, delete it
    if dir == None:
        dir = BACKUP_DIR
        print "Deleting folder %s" % dir

    for entry in os.listdir(dir):
        path = dir + '/' + entry
        if os.path.isdir(path):
            delete_backup_dir(path)
        elif os.path.isfile(path):
            os.unlink(path)
    os.rmdir(dir)
    
def restore_files():
    # Something went wrong
    global config_files
    global files_to_backup

    print "Restoring files from %s" % BACKUP_DIR
    
    # Unlink all conf files just created
    for file in config_files:
        os.unlink(file['path'])

    # Restore backup files
    for file in files_to_backup:
        os.rename(file['backup_path'], file['path'])


def restart_services():
    global restart
    already_restart = []
    for plugin in PLUGINS:
        if plugin.SERVICE_NAME in restart or 'all' in restart:
            if not plugin.restart_service(sjconf, already_restart):
                raise Exception('Failed to restart all services.')

def apply_confs():
    global config_files
    # Open and write all configuration files
    for conf in config_files:
        print "Writing configuration file %(path)s (%(service)s)" % conf
        open(conf['path'], "w").write(conf['content'])
    print ''

def deploy_conf():
    global files_to_backup
    global config_files
    global config

    # Creating a dict with list of base conf dicts
    for dic_key in base:
        for key in base[dic_key]:
            config['%s:%s' % (dic_key, key)] = base[dic_key][key]

    # Updating this dict with list of local conf dicts
    for dic_key in local:
        for key in local[dic_key]:
            config['%s:%s' % (dic_key, key)] = local[dic_key][key]

    # Init all plugins (they will create their file internaly and communicate with other plugins)
    for plugin in PLUGINS:
        plugin.init(sjconf, base, local, config)

    # Once each plugin has finished, get conf files
    for plugin in PLUGINS:
        config_files += plugin.get_conf_files()

    # Backup all files
    backup_files()

    try:
        # Write all configuration files
        apply_confs()

        # restart services if asked (--restart)
        if restart: 
            restart_services()
        print ''
    except:
        print_traceback()
        # Something when wrong, restoring backup files
        restore_files()
        if restart: 
            restart_services()
        # And delete backup folder
        delete_backup_dir()
        sys.exit(0)

    # Only archive once everything is OK
    archive_backup()
    print ''

    # Delete backup, everything is cool
    delete_backup_dir()

def usage(exit_code):
    print '''sjconf usage:
    --diff                   : show 'diff -u' between old and new configuration files
    --save                   : save modification (mandatory to deploy)
    --deploy                 : deploy configuration
    --restart                : restart all services 
    --set section key value  : set a configuration key
    --delete-key section key : delete a key within a section
    --delete-section section : delete a complete section
'''

    if exit_code:
        print "No modification done on configuration"

    sys.exit(exit_code)


def apply_conf_modifications(out_file, show):
    global local
    global delete_sections
    global delete_keys
    global sets

    if sets or delete_keys or delete_sections:
        print "########## Scheduled modifications ##############"

        for section in delete_sections:
            if section in local:
                del(local[section])
            print 'delete section : %s' % (section)

        for section, key in delete_keys:
            if section in local:
                if key in local[section]:
                    del(local[section][key])
            print 'delete key     : %s:%s' % (section, key)

        for section, key, value in sets:
            local.setdefault(section, {})
            local[section][key] = value
            print 'set            : %s:%s=%s' % (section, key, value)
        print "#################################################\n"

    cp = ConfigParser.RawConfigParser()
    for section in local:
        cp.add_section(section)
        for key in local[section]:
            cp.set(section, key, local[section][key])

    cp.write(open(out_file, "w"))
    if show:
        print "############### local.conf diffs ################"
        os.system("diff -U -1 %s %s" % (LOCAL_FILE, TEMP_FILE))
        print "#################################################\n"



argv = list(sys.argv)
bin, argv = argv[0], argv[1:]
if not argv:
    if verbose:
        print 'Using base configuration file: %s' % BASE_FILE
        print 'Using local configuration file: %s' % LOCAL_FILE
        print ''

    print open(LOCAL_FILE, "r").read()
    sys.exit(0)

class BadParam:
    def __init__(self, name):
        self.name = name

def get_params(argv, nb):
    if len(argv) < nb:
        raise BadParam("nb")
    ret = argv[0:nb]
    for i in range(0, nb):
        argv.pop(0)
    return ret

while len(argv):
    cmd, argv = argv[0], argv[1:]
    try:
        if cmd == '--deploy':
            deploy = True
        elif cmd == '-h' or cmd == '--help':
             usage(0)
        elif cmd == '-v' or cmd == '--verbose':
            verbose = True
        elif cmd == '--diff':
            diff = True
        elif cmd == '--save':
            save = True
        elif cmd == '--restart':
            restart += get_params(argv, 1)
        elif cmd == '--get':
            get = get_params(argv, 2)
        elif cmd == '--set':
            sets += [get_params(argv, 3)]
        elif cmd == '--delete-section':
            delete_sections += get_params(argv, 1)
        elif cmd == '--delete-key':
            delete_keys += [get_params(argv, 2)]
        else:
            print 'Incorrect command : %s\n' % cmd
            usage(1)
    except BadParam, param:
        print 'Incorrect %s command\n' % param
        usage(1)


changes = (sets or delete_sections or delete_keys)


if get:
    if changes or deploy or save or restart:
        print 'Cannot mix get command and other command'
        sys.exit(0)
    if get[0] in local and get[1] in local[get[0]]:
        print local[get[0]][get[1]]
        sys.exit(0)
    else:
        sys.exit(1)
        
if verbose:
    print 'Using base configuration file: %s' % BASE_FILE
    print 'Using local configuration file: %s' % LOCAL_FILE
    print ''

if changes and deploy and not (save):
    print 'You should add the --save parameter to save configuration before deploying it'
    sys.exit(1)

if save:
    apply_conf_modifications(LOCAL_FILE, False)
    print 'Configuration saved\n'
else:
    apply_conf_modifications(TEMP_FILE, diff)
    if changes:
        print "No configuration saved (use --save)\n"
        sys.exit(1)

if not deploy and restart:
    restart_services()
    
if deploy:
    deploy_conf()

