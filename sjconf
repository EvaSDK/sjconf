#!/usr/bin/python

import traceback, time, os, sys, popen2, ConfigParser
from pprint import pprint


def load_conf(filename):
    if not os.path.isfile(filename):
        sys.stderr.write('Cannot open file %s\n' % filename)
        sys.exit(1)
    cp = ConfigParser.RawConfigParser()
    cp.read(filename)
    return dict(map(lambda a, b:  (a , dict(cp.items(a))), cp.sections(), {}))
    
sjconf     = load_conf('/etc/default/sjconf')
sys.path   += [sjconf['conf']['plugins_path']]

import openvpn, iptables, shaping, hosts

BASE_FILE  = os.path.realpath(sjconf['conf']['base_path'] + '/base.conf')
LOCAL_FILE = os.path.realpath(sjconf['conf']['base_path'] + '/local.conf')
BACKUP_DIR = os.path.realpath(sjconf['conf']['backup_dir'] + '/' + time.strftime('%F-%R:%S', time.localtime()) )
PLUGINS    = [openvpn, iptables, shaping, hosts]
TEMP_FILE  = "/tmp/sjconf_tempfile.conf"

base            = load_conf(BASE_FILE)
local           = load_conf(LOCAL_FILE)

def print_traceback():
    traceback.print_exc(file=sys.stdout)


def backup_files():
    global files_to_backup

    print "Backup folder : %s" % BACKUP_DIR
    os.makedirs(BACKUP_DIR)

    for plugin in PLUGINS:
        files_to_backup += plugin.get_files_to_backup()

    for file in files_to_backup:
        if not os.path.isdir( BACKUP_DIR + '/' + file['service']):
            os.makedirs(BACKUP_DIR + '/' + file['service'])
        file['backup_path'] = BACKUP_DIR + '/' + file['service'] + '/' + os.path.basename(file['path'])
        os.rename(file['path'], file['backup_path'])


def archive_backup():
    path    = "%s/sjconf_backup_%s.tgz" % (os.path.dirname(BACKUP_DIR), os.path.basename(BACKUP_DIR))
    print "Backup file : %s" % path

    tar     = popen2.Popen3( "tar zcvf %s %s" % (path, BACKUP_DIR) , True)
    fdout   = tar.fromchild.fileno()
    fderr   = tar.childerr.fileno()
    datout  = tar.fromchild.read()
    daterr  = tar.childerr.read()

    if tar.wait():
        print "Cannot archive backup dir %s/ to %s, please do it manually" % (BACKUP_DIR, path)
        print "tar output:\n\n" + daterr

def delete_backup_dir(dir=None):
    if dir == None:
        dir = BACKUP_DIR
        print "Deleting folder %s" % dir

    for entry in os.listdir(dir):
        path = dir + '/' + entry
        if os.path.isdir(path):
            delete_backup_dir(path)
        elif os.path.isfile(path):
            os.unlink(path)
    os.rmdir(dir)
    
def restore_files():
    global conf_files
    global files_to_backup

    print "Restoring files from %s" % BACKUP_DIR
    
    for file in conf_files:
        os.unlink(file['path'])

    for file in files_to_backup:
        os.rename(file['backup_path'], file['path'])


def restart_services():
    already_restart = []
    for plugin in PLUGINS:
        plugin.restart_service(already_restart)


def apply_confs():
    global conf_files
    for conf in conf_files:
        print "Writing configuration file %(path)s (%(service)s)" % conf
        open(conf['path'], "w").write(conf['content'])
    print ''

def deploy_conf():

    config          = {}
    conf_files       = []
    files_to_backup = []

    for dic_key in base:
        for key in base[dic_key]:
            config['%s:%s' % (dic_key, key)] = base[dic_key][key]

    for dic_key in local:
        for key in local[dic_key]:
            config['%s:%s' % (dic_key, key)] = local[dic_key][key]

    for plugin in PLUGINS:
        plugin.init(sjconf, base, local, config)

    for plugin in PLUGINS:
        conf_files += plugin.get_conf_files()

    backup_files()

    try:
        archive_backup()
        print ''
        apply_confs()
        restart_services()
        print ''
    except:
        print_traceback()
        restore_files()
        delete_backup_dir()
        sys.exit(0)

    #FIXME TO remove
    #restore_files()


    delete_backup_dir()

global delete_sections
global delete_keys
global sets
global deploy
global restart
global save
global diff
global verbose

deploy=False
restart=False
sets=[]
delete_keys=[]
delete_sections=[]
save=False
diff=False
verbose=False

def usage(exit_code):
    print '''sjconf usage:
    --diff                   : show 'diff -u' between old and new configuration files
    --save                   : save modification (mandatory to deploy)
    --deploy                 : deploy configuration
    --restart                : restart all services 
    --set section key value  : set a configuration key
    --delete-key section key : delete a key within a section
    --delete-section section : delete a complete section
'''

    if exit_code:
        print "No modification done on configuration"

    sys.exit(exit_code)


def apply_conf_modifications(out_file, show):
    global local
    global delete_sections
    global delete_keys
    global sets

    if sets or delete_keys or delete_sections:
        print "########## Scheduled modifications ##############"

        for section in delete_sections:
            if section in local:
                del(local[section])
            print 'delete section : %s' % (section)

        for section, key in delete_keys:
            if section in local:
                if key in local[section]:
                    del(local[section][key])
            print 'delete key     : %s:%s' % (section, key)

        for section, key, value in sets:
            local.setdefault(section, {})
            local[section][key] = value
            print 'set            : %s:%s=%s' % (section, key, value)
        print "#################################################\n"

    cp = ConfigParser.RawConfigParser()
    for section in local:
        cp.add_section(section)
        for key in local[section]:
            cp.set(section, key, local[section][key])

    cp.write(open(out_file, "w"))
    if show:
        print "############### local.conf diffs ################"
        os.system("diff -U -1 %s %s" % (LOCAL_FILE, TEMP_FILE))
        print "#################################################\n"



argv = list(sys.argv)
bin, argv = argv[0], argv[1:]
if not argv:
    if verbose:
        print 'Using base configuration file: %s' % BASE_FILE
        print 'Using local configuration file: %s' % LOCAL_FILE
        print ''

    print open(LOCAL_FILE, "r").read()
    sys.exit(0)

class BadParam:
    def __init__(self, name):
        self.name = name

def get_params(argv, nb):
    if len(argv) < nb:
        raise BadParam("nb")
    ret = argv[0:nb]
    for i in range(0, nb):
        argv.pop(0)
    return ret

while len(argv):
    cmd, argv = argv[0], argv[1:]
    try:
        if cmd == '--deploy':
            deploy = True
        elif cmd == '-h' or cmd == '--help':
             usage(0)
        elif cmd == '-v' or cmd == '--verbose':
            verbose = True
        elif cmd == '--diff':
            diff = True
        elif cmd == '--save':
            save = True
        elif cmd == '--restart':
            restart = True
        elif cmd == '--set':
            sets += [get_params(argv, 3)]
        elif cmd == '--delete-section':
            delete_sections += get_params(argv, 1)
        elif cmd == '--delete-key':
            delete_keys += [get_params(argv, 2)]
        else:
            print 'Incorrect command : %s\n' % cmd
            usage(1)
    except BadParam, param:
        print 'Incorrect %s command\n' % param
        usage(1)



if verbose:
    print 'Using base configuration file: %s' % BASE_FILE
    print 'Using local configuration file: %s' % LOCAL_FILE
    print ''

changes = sets or delete_sections or delete_keys

if changes and deploy and not (save):
    print 'You should add the --save parameter to save configuration before deploying it'
    sys.exit(1)

if save:
    apply_conf_modifications(LOCAL_FILE, False)
    print 'Configuration saved\n'
else:
    apply_conf_modifications(TEMP_FILE, diff)
    if changes:
        print "No configuration saved (use --save)\n"
    sys.exit(1)
    

