#!/usr/bin/python

import traceback, time, os, sys, popen2, ConfigParser, shutil, errno, string
from pprint import pprint

def my_exit():
    os.execv("/bin/false", ['/bin/false'])

def load_conf(filename):
    # Configuration file loader
    if not os.path.isfile(filename):
        sys.stderr.write('Cannot open file %s\n' % filename)
        my_exit()
    cp = ConfigParser.RawConfigParser()
    cp.read(filename)
    return dict(map(lambda a, b:  (a , dict(cp.items(a))), cp.sections(), {}))

sjconf     = load_conf('/etc/smartjog/sjconf')

# Defining useful variables
BASE_FILE    = os.path.realpath(sjconf['conf']['base_path'] + '/base.conf')
LOCAL_FILE   = os.path.realpath(sjconf['conf']['base_path'] + '/local.conf')
BACKUP_DIR   = os.path.realpath(sjconf['conf']['backup_dir'] + '/' + time.strftime('%F-%R:%S', time.localtime()) )
ETC_DIR      = os.path.realpath(sjconf['conf']['etc_dir'])
PLUGIN_NAMES = map(string.strip, sjconf['conf']['plugins'].split(','))
TEMP_FILE    = "/tmp/sjconf_tempfile.conf"
PLUGINS_PATH = os.path.realpath(sjconf['conf']['plugins_path'])

# Adding plugin folder to sys path
sys.path.append(PLUGINS_PATH)

# Load the plugins
PLUGINS = []
for plugin in PLUGIN_NAMES:
    PLUGINS.append(__import__(plugin))

base            = load_conf(BASE_FILE)
local           = load_conf(LOCAL_FILE)

# Global variables used on functions
global files_to_backup
global delete_sections
global delete_keys
global sets
global get
global deploy
global restart
global save
global diff
global verbose

config          = {}
config_files    = []
files_to_backup = []
get             = []
sets            = []
delete_keys     = []
delete_sections = []
restart         = []
plugins_to_install = []
plugins_to_uninstall = []
deploy          = False
save            = False
diff            = False
verbose         = False
quiet           = False

def my_print(p):
    if not quiet: print p

def print_traceback():
    traceback.print_exc(file=sys.stdout)

def exec_command(command):
    # Using popen to know program output
    cmd     = popen2.Popen3(command, True)
    fdout   = cmd.fromchild.fileno()
    fderr   = cmd.childerr.fileno()
    datout  = cmd.fromchild.read()
    daterr  = cmd.childerr.read()

    if cmd.wait():
        return "%s" %  (daterr)


def backup_files():
    global files_to_backup

    my_print( "Backup folder : %s" % BACKUP_DIR )
    os.makedirs(BACKUP_DIR)

    # Ask all plugins a list of files that I should backup for them
    try:
        for plugin in PLUGINS:
            files_to_backup += plugin.get_files_to_backup()
    except Exception, e:
        print "Fails to get files to backup: " + str(e)
        sys.exit(1)

    os.makedirs(BACKUP_DIR + '/sjconf/')
    ret = exec_command("cp '%s' '%s'" % (LOCAL_FILE, BACKUP_DIR + '/sjconf/local.conf'))
    if ret:
        print ret
        sys.exit(0)


    # Store all files into a service dedicated folder
    for file in files_to_backup:
        if not os.path.isdir( BACKUP_DIR + '/' + file['service']):
            os.makedirs(BACKUP_DIR + '/' + file['service'])
        file['backup_path'] = BACKUP_DIR + '/' + file['service'] + '/' + os.path.basename(file['path'])
        ret = exec_command("mv '%s' '%s'" % (file['path'], file['backup_path']))
        if False:
            print ret
            file['backed_up'] = True
            print "Please restore files manually from %s" % BACKUP_DIR
            return ret
        file['backed_up'] = True

def archive_backup():
    # Once configuration is saved, we can archive backup into a tgz

    path    = "%s/sjconf_backup_%s.tgz" % (os.path.dirname(BACKUP_DIR), os.path.basename(BACKUP_DIR))
    my_print("Backup file : %s" % path)

    ret = exec_command("tar zcvf %s %s" % (path, BACKUP_DIR))
    if ret:
        print ret
        print "Cannot archive backup dir %s/ to %s, please do it manually" % (BACKUP_DIR, path)

def delete_backup_dir(dir=None):
    # Once backup has been archived, delete it
    if dir == None:
        dir = BACKUP_DIR
        my_print("Deleting folder %s" % dir)

    for entry in os.listdir(dir):
        path = dir + '/' + entry
        if os.path.isdir(path):
            delete_backup_dir(path)
        elif os.path.isfile(path):
            os.unlink(path)
    os.rmdir(dir)

def restore_files():
    # Something went wrong
    global config_files
    global files_to_backup

    print "Restoring files from %s" % BACKUP_DIR

    # Unlink all conf files just created
    for file in config_files:
        if 'written' in file and file['written'] and os.path.isfile(file['path']):
            os.unlink(file['path'])

    # Restore backup files
    for file in files_to_backup:
        if file['backed_up']:
            ret = exec_command("mv '%s' '%s'" % (file['backup_path'], file['path']))
            if ret:
                print ret
                print "Please restore files manually from %s" % BACKUP_DIR
                return ret

def restart_services():
    global restart
    already_restart = []
    for plugin in PLUGINS:
        if plugin.SERVICE_NAME in restart or 'all' in restart:
            if not plugin.restart_service(sjconf, already_restart):
                raise Exception('Failed to restart all services.')

def apply_confs():
    global config_files
    # Open and write all configuration files
    try:
        for conf in config_files:
            my_print("Writing configuration file %(path)s (%(service)s)" % conf)
            # checking if the dirname exists
            folder = os.path.dirname(conf['path'])
            if not os.path.isdir(folder):
                os.makedirs(folder)
            open(conf['path'], "w").write(conf['content'])
            conf['written'] = True
        my_print('')
    except Exception, e:
        print "Failed to write configuration: %s.\nRestoring..." % str(e)
        restore_files()
        restart_services()
        my_exit()

def deploy_conf():
    global files_to_backup
    global config_files
    global config

    # Creating a dict with list of base conf dicts
    for dic_key in base:
        for key in base[dic_key]:
            config['%s:%s' % (dic_key, key)] = base[dic_key][key]

    # Updating this dict with list of local conf dicts
    for dic_key in local:
        for key in local[dic_key]:
            config['%s:%s' % (dic_key, key)] = local[dic_key][key]

    # Init all plugins (they will create their file internaly and communicate with other plugins)
    try:
        for plugin in PLUGINS:
            plugin.init(sjconf, base, local, config)
    except Exception, e:
        print "Failed to initialize all plugins: %s\nTerminating." % str(e)
        print_traceback()
        return

    # Once each plugin has finished, get conf files
    for plugin in PLUGINS:
        config_files += plugin.get_conf_files()

    # Backup all files
    if backup_files():
        sys.exit(0)

    try:
        # Write all configuration files
        apply_confs()

        # restart services if asked (--restart)
        if restart:
            restart_services()
        my_print('')
    except:
        print_traceback()
        # Something when wrong, restoring backup files
        if restore_files():
            sys.exit(0)

        if restart:
            restart_services()
        # And delete backup folder
        delete_backup_dir()
        sys.exit(0)

    # Only archive once everything is OK
    archive_backup()
    my_print('')

    # Delete backup, everything is cool
    delete_backup_dir()

def usage(exit_code):
    print '''sjconf usage:
    --diff                    : show 'diff -u' between old and new configuration files
    --save                    : save modification (mandatory to deploy)
    --deploy                  : deploy configuration
    --restart                 : restart all services
    --set section key value   : set a configuration key
    --delete-key section key  : delete a key within a section
    --delete-section section  : delete a complete section
    --install-plugin plugin   : install ``plugin'' into the plugins path
    --uninstall-plugin plugin : uninstall ``plugin'' from the plugins path
'''

    if exit_code:
        my_print("No modification done on configuration")

    sys.exit(exit_code)


def apply_conf_modifications(out_file, show):
    global local
    global delete_sections
    global delete_keys
    global sets

    if sets or delete_keys or delete_sections:
        my_print("########## Scheduled modifications ##############")

        for section in delete_sections:
            if section in local:
                del(local[section])
            my_print('delete section : %s' % (section))

        for section, key in delete_keys:
            if section in local:
                if key in local[section]:
                    del(local[section][key])
            my_print('delete key     : %s:%s' % (section, key))

        for section, key, value in sets:
            local.setdefault(section, {})
            local[section][key] = value
            my_print('set            : %s:%s=%s' % (section, key, value))
        my_print("#################################################\n")

    cp = ConfigParser.RawConfigParser()
    for section in local:
        cp.add_section(section)
        for key in local[section]:
            cp.set(section, key, local[section][key])

    cp.write(open(out_file, "w"))
    if show:
        print "############### local.conf diffs ################"
        os.system("diff -U -1 %s %s" % (LOCAL_FILE, TEMP_FILE))
        print "#################################################\n"

def plugin_install(plugin_to_install):
    if verbose:
        my_print("Installing plugin: %s" % (plugin_to_install))
    if os.path.exists(PLUGINS_PATH + '/' + os.path.basename(plugin_to_install)):
        raise IOError((errno.EEXIST, "plugin %s already installed" % (plugin_to_install)))
    shutil.copy(plugin_to_install, PLUGINS_PATH)
    if verbose:
        my_print("Installed plugin: %s" % (plugin_to_install))

def plugin_uninstall(plugin_to_uninstall):
    if verbose:
        my_print("Uninstalling plugin: %s" % (plugin_to_uninstall))
    plugin_to_uninstall_path = PLUGINS_PATH + '/' + plugin_to_uninstall
    if not os.path.exists(plugin_to_uninstall_path):
        plugin_to_uninstall_path += '.py'
    if not os.path.exists(plugin_to_uninstall_path):
        raise IOError((errno.ENOENT, "plugin %s not installed" % (plugin_to_uninstall)))
    os.unlink(plugin_to_uninstall_path)
    if verbose:
        my_print("Uninstalled plugin: %s" % (plugin_to_uninstall))


argv = list(sys.argv)
bin, argv = argv[0], argv[1:]
if not argv:
    if verbose:
        my_print('Using base configuration file: %s' % BASE_FILE)
        my_print('Using local configuration file: %s' % LOCAL_FILE)
        my_print('')

    my_print( open(LOCAL_FILE, "r").read())
    sys.exit(0)

class BadParam:
    def __init__(self, name):
        self.name = name

def get_params(argv, nb):
    if len(argv) < nb:
        raise BadParam("nb")
    ret = argv[0:nb]
    for i in range(0, nb):
        argv.pop(0)
    return ret

while len(argv):
    cmd, argv = argv[0], argv[1:]
    try:
        if cmd == '-e':
            editor = os.getenv("EDITOR") or "vim"
            os.system("%s /etc/smartjog/local.conf" % editor)
            sys.exit(0)
        if cmd == '--deploy':
            deploy = True
        elif cmd == '-h' or cmd == '--help':
             usage(0)
        elif cmd == '-v' or cmd == '--verbose':
            verbose = True
        elif cmd == '--diff':
            diff = True
        elif cmd == '--quiet':
            quiet = True
        elif cmd == '--save':
            save = True
        elif cmd == '--restart':
            restart += get_params(argv, 1)
        elif cmd == '--get':
            get = get_params(argv, 2)
        elif cmd == '--set':
            sets += [get_params(argv, 3)]
        elif cmd == '--delete-section':
            delete_sections += get_params(argv, 1)
        elif cmd == '--delete-key':
            delete_keys += [get_params(argv, 2)]
        elif cmd == '--install-plugin':
            plugins_to_install += get_params(argv, 1)
        elif cmd == '--uninstall-plugin':
            plugins_to_uninstall += get_params(argv, 1)
        else:
            print 'Incorrect command : %s\n' % cmd
            usage(1)
    except BadParam, param:
        print 'Incorrect %s command\n' % param
        usage(1)


changes = (sets or delete_sections or delete_keys)


if get:
    if changes or deploy or save or restart:
        print 'Cannot mix get command and other command'
        sys.exit(0)
    if get[0] in local and get[1] in local[get[0]]:
        print local[get[0]][get[1]]
        sys.exit(0)
    else:
        sys.exit(1)

if verbose:
    my_print('Using base configuration file: %s' % BASE_FILE)
    my_print('Using local configuration file: %s' % LOCAL_FILE)
    my_print('')

if changes and deploy and not (save):
    print 'You should add the --save parameter to save configuration before deploying it'
    sys.exit(1)

if save:
    apply_conf_modifications(LOCAL_FILE, False)
    my_print('Configuration saved\n')
else:
    apply_conf_modifications(TEMP_FILE, diff)
    if changes:
        my_print("No configuration saved (use --save)\n")
        sys.exit(1)

if not deploy and restart:
    restart_services()

if deploy:
    deploy_conf()

if plugins_to_install:
    for plugin_to_install in plugins_to_install:
        plugin_install(plugin_to_install)

if plugins_to_uninstall:
    for plugin_to_uninstall in plugins_to_uninstall:
        plugin_uninstall(plugin_to_uninstall)
