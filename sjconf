#!/usr/bin/python

import traceback, time, os, sys, popen2, ConfigParser
from pprint import pprint

def load_conf(filename):
    if not os.path.isfile(filename):
        sys.stderr.write('Cannot open file %s\n' % filename)
        sys.exit(1)
    cp = ConfigParser.RawConfigParser()
    cp.read(filename)
    return dict(map(lambda a, b:  (a , dict(cp.items(a))), cp.sections(), {}))
    
sjconf     = load_conf('/etc/default/sjconf')
sys.path   += [sjconf['conf']['plugins_path']]

import openvpn, iptables, shaping, hosts

BASE_FILE  = os.path.realpath(sjconf['conf']['base_path'] + '/base.conf')
LOCAL_FILE = os.path.realpath(sjconf['conf']['base_path'] + '/local.conf')
BACKUP_DIR = os.path.realpath(sjconf['conf']['backup_dir'] + '/' + time.strftime('%F-%R:%S', time.localtime()) )
PLUGINS    = [openvpn, iptables, shaping, hosts]

base            = load_conf(BASE_FILE)
local           = load_conf(LOCAL_FILE)

def print_traceback():
    traceback.print_exc(file=sys.stdout)


def backup_files():
    global files_to_backup

    print "Backup folder : %s" % BACKUP_DIR
    os.makedirs(BACKUP_DIR)

    for plugin in PLUGINS:
        files_to_backup += plugin.get_files_to_backup()

    for file in files_to_backup:
        if not os.path.isdir( BACKUP_DIR + '/' + file['service']):
            os.makedirs(BACKUP_DIR + '/' + file['service'])
        file['backup_path'] = BACKUP_DIR + '/' + file['service'] + '/' + os.path.basename(file['path'])
        os.rename(file['path'], file['backup_path'])


def archive_backup():
    path    = "%s/sjconf_backup_%s.tgz" % (os.path.dirname(BACKUP_DIR), os.path.basename(BACKUP_DIR))
    print "Backup file : %s" % path

    tar     = popen2.Popen3( "tar zcvf %s %s" % (path, BACKUP_DIR) , True)
    fdout   = tar.fromchild.fileno()
    fderr   = tar.childerr.fileno()
    datout  = tar.fromchild.read()
    daterr  = tar.childerr.read()

    if tar.wait():
        print "Cannot archive backup dir %s/ to %s, please do it manually" % (BACKUP_DIR, path)
        print "tar output:\n\n" + daterr

def delete_backup_dir(dir=None):
    if dir == None:
        dir = BACKUP_DIR
        print "Deleting folder %s" % dir

    for entry in os.listdir(dir):
        path = dir + '/' + entry
        if os.path.isdir(path):
            delete_backup_dir(path)
        elif os.path.isfile(path):
            os.unlink(path)
    os.rmdir(dir)
    
def restore_files():
    global conf_files
    global files_to_backup

    print "Restoring files from %s" % BACKUP_DIR
    
    for file in conf_files:
        os.unlink(file['path'])

    for file in files_to_backup:
        os.rename(file['backup_path'], file['path'])


def restart_services():
    already_restart = []
    for plugin in PLUGINS:
        plugin.restart_service(already_restart)


def deploy_confs():
    global conf_files
    for conf in conf_files:
        print "Writing configuration file %(path)s (%(service)s)" % conf
        open(conf['path'], "w").write(conf['content'])
    print ''

def deploy():

    config          = {}
    conf_files       = []
    files_to_backup = []

    for dic_key in base:
        for key in base[dic_key]:
            config['%s:%s' % (dic_key, key)] = base[dic_key][key]

    for dic_key in local:
        for key in local[dic_key]:
            config['%s:%s' % (dic_key, key)] = local[dic_key][key]

    for plugin in PLUGINS:
        plugin.init(sjconf, base, local, config)

    for plugin in PLUGINS:
        conf_files += plugin.get_conf_files()

    backup_files()

    try:
        archive_backup()
        print ''
        deploy_confs()
        restart_services()
        print ''
    except:
        print_traceback()
        restore_files()
        delete_backup_dir()
        sys.exit(0)

    #FIXME TO remove
    #restore_files()


    delete_backup_dir()

global delete_sections
global delete_keys
global sets


deploy=True
restart=True
sets=[]
delete_keys=[]
delete_sections=[]

def usage(exit_code):
    print '''sjconf usage:
    --deploy                 : deploy configuration
    --restart                : restart all services 
    --set section key value  : set a configuration key
    --delete-key section key : delete a key within a section
    --delete-section section : delete a complete section

No modification done on configuration
    '''
    sys.exit(exit_code)


def apply_conf_modifications():
    global local
    global delete_sections
    global delete_keys
    global sets

    print sets
    print delete_keys
    print delete_sections

    for section in delete_sections:
        if section in local:
            del(local[section])
        print 'delete section %s' % (section)

    for section, key in delete_keys:
        if section in local:
            del(local[section][key])
        print 'delete key %s:%s' % (section, key)

    for section, key, value in sets:
        local.setdefault(section, {})
        local[section][key] = value
        print 'set %s:%s=%s' % (section, key, value)


argv = list(sys.argv)
bin, argv = argv[0], argv[1:]
if not argv:
    usage(1)

class BadParam:
    def __init__(self, name):
        self.name = name

def get_params(argv, nb):
    if len(argv) < nb:
        raise BadParam("nb")
    ret = argv[0:nb]
    for i in range(0, nb):
        argv.pop(0)
    return [ret]

while len(argv):
    cmd, argv = argv[0], argv[1:]
    try:
        if cmd == '--deploy':
            deploy = True
        elif cmd == '--restart':
            restart = True
        elif cmd == '--set':
            sets += get_params(argv, 3)
        elif cmd == '--delete-section':
            delete_sections += get_params(argv, 1)
        elif cmd == '--delete-key':
            delete_keys += get_params(argv, 2)
        else:
            print 'Incorrect command : %s\n' % cmd
            usage(1)
    except BadParam, param:
        print 'Incorrect %s command\n' % param
        usage(1)



print 'Using base configuration file: %s' % BASE_FILE
print 'Using local configuration file: %s' % LOCAL_FILE
print ''

apply_conf_modifications()
